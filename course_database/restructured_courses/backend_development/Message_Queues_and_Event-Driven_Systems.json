{
  "id": "BE4",
  "name": "Message Queues & Event-Driven Systems",
  "category": "Backend Development",
  "primary_tech": "Message Queues",
  "topics": [
    "Publish/Subscribe Patterns",
    "RabbitMQ/Kafka Basics",
    "Idempotency & Dead Letter Queues"
  ],
  "recommended": false,
  "tags": [
    "messaging",
    "architecture",
    "distributed-systems"
  ],
  "resources": {
    "docs": [
      {
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model",
        "description": "An overview of JavaScript's execution model, including the call stack, event loop, and concurrency model."
      },
      {
        "url": "https://nodejs.org/api/events.html",
        "description": "The Node.js Events API documentation details the EventEmitter class for handling events and asynchronous operations in Node.js applications."
      },
      {
        "url": "https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick",
        "description": "An explanation of how Node.js handles asynchronous operations using the event loop, timers, and process.nextTick()."
      }
    ],
    "notes": [
      {
        "url": "https://www.geeksforgeeks.org/advance-java/event-driven-communication-with-messaging-queues/",
        "description": "This resource explains how to implement event-driven communication using messaging queues in advanced Java applications."
      },
      {
        "url": "https://www.geeksforgeeks.org/system-design/event-driven-architecture-system-design/",
        "description": "An overview of event-driven architecture, explaining its principles, components, and benefits in system design."
      },
      {
        "url": "https://www.geeksforgeeks.org/system-design/message-driven-architecture-vs-event-driven-architecture/",
        "description": "This resource compares message-driven and event-driven architectures, highlighting their differences and use cases in system design."
      },
      {
        "url": "https://www.geeksforgeeks.org/system-design/error-handling-in-event-driven-architecture/",
        "description": "An overview of error handling strategies in event-driven architecture systems."
      },
      {
        "url": "https://www.geeksforgeeks.org/system-design/message-broker-vs-message-queue/",
        "description": "This resource explains the differences and use cases of message brokers and message queues in system design."
      }
    ],
    "videos": [
      "https://www.youtube.com/watch?v=gOuAqRaDdHA",
      "https://www.youtube.com/watch?v=DYFocSiPOl8",
      "https://www.youtube.com/watch?v=NQ3fZtyXji0",
      "https://www.youtube.com/watch?v=oUJbuFMyBDk",
      "https://www.youtube.com/watch?v=xErwDaOc-Gs"
    ]
  },
  "quiz": [
    {
      "question": "What is the primary advantage of using a Publish/Subscribe pattern in message queues?",
      "options": [
        "Allows direct communication between sender and receiver",
        "Enables asynchronous communication and decoupling of services",
        "Increases the security of message transmission",
        "Reduces the overall cost of message processing"
      ],
      "correct_option": 1,
      "hint": "Think about how services interact and remain independent."
    },
    {
      "question": "Which of the following is a key feature of RabbitMQ?",
      "options": [
        "Built-in support for distributed transactions",
        "Advanced real-time analytics",
        "Support for multiple messaging protocols",
        "Integrated machine learning capabilities"
      ],
      "correct_option": 2,
      "hint": "Consider RabbitMQ's versatility in handling different protocols."
    },
    {
      "question": "In Kafka, what is the purpose of a consumer group?",
      "options": [
        "To ensure load balancing across multiple producers",
        "To allow multiple consumers to read from a partition independently",
        "To aggregate messages from multiple topics",
        "To coordinate the processing of messages across multiple consumers"
      ],
      "correct_option": 3,
      "hint": "Think about how Kafka manages consumption of messages across different clients."
    },
    {
      "question": "What does idempotency ensure in the context of message processing?",
      "options": [
        "Every message is processed exactly once",
        "Duplicate messages are ignored, ensuring only one processing",
        "Messages are processed in the order they are received",
        "Only authorized users can send messages"
      ],
      "correct_option": 1,
      "hint": "It's about handling duplicate messages."
    },
    {
      "question": "What is a Dead Letter Queue (DLQ) used for in message queuing systems?",
      "options": [
        "To temporarily store messages during maintenance",
        "To hold messages that cannot be processed successfully",
        "To archive messages after processing",
        "To encrypt messages before transmission"
      ],
      "correct_option": 1,
      "hint": "Think about where problematic messages are stored for later analysis."
    }
  ]
}